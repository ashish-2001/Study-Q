
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `VideoProgress` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model VideoProgress
 * 
 */
export type VideoProgressModel = runtime.Types.Result.DefaultSelection<Prisma.$VideoProgressPayload>

export type AggregateVideoProgress = {
  _count: VideoProgressCountAggregateOutputType | null
  _avg: VideoProgressAvgAggregateOutputType | null
  _sum: VideoProgressSumAggregateOutputType | null
  _min: VideoProgressMinAggregateOutputType | null
  _max: VideoProgressMaxAggregateOutputType | null
}

export type VideoProgressAvgAggregateOutputType = {
  id: number | null
  contentId: number | null
  currentTimestamp: number | null
}

export type VideoProgressSumAggregateOutputType = {
  id: number | null
  contentId: number | null
  currentTimestamp: number | null
}

export type VideoProgressMinAggregateOutputType = {
  id: number | null
  userId: string | null
  contentId: number | null
  currentTimestamp: number | null
  markAsCompleted: boolean | null
  updatedAt: Date | null
}

export type VideoProgressMaxAggregateOutputType = {
  id: number | null
  userId: string | null
  contentId: number | null
  currentTimestamp: number | null
  markAsCompleted: boolean | null
  updatedAt: Date | null
}

export type VideoProgressCountAggregateOutputType = {
  id: number
  userId: number
  contentId: number
  currentTimestamp: number
  markAsCompleted: number
  updatedAt: number
  _all: number
}


export type VideoProgressAvgAggregateInputType = {
  id?: true
  contentId?: true
  currentTimestamp?: true
}

export type VideoProgressSumAggregateInputType = {
  id?: true
  contentId?: true
  currentTimestamp?: true
}

export type VideoProgressMinAggregateInputType = {
  id?: true
  userId?: true
  contentId?: true
  currentTimestamp?: true
  markAsCompleted?: true
  updatedAt?: true
}

export type VideoProgressMaxAggregateInputType = {
  id?: true
  userId?: true
  contentId?: true
  currentTimestamp?: true
  markAsCompleted?: true
  updatedAt?: true
}

export type VideoProgressCountAggregateInputType = {
  id?: true
  userId?: true
  contentId?: true
  currentTimestamp?: true
  markAsCompleted?: true
  updatedAt?: true
  _all?: true
}

export type VideoProgressAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which VideoProgress to aggregate.
   */
  where?: Prisma.VideoProgressWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of VideoProgresses to fetch.
   */
  orderBy?: Prisma.VideoProgressOrderByWithRelationInput | Prisma.VideoProgressOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.VideoProgressWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` VideoProgresses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` VideoProgresses.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned VideoProgresses
  **/
  _count?: true | VideoProgressCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: VideoProgressAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: VideoProgressSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: VideoProgressMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: VideoProgressMaxAggregateInputType
}

export type GetVideoProgressAggregateType<T extends VideoProgressAggregateArgs> = {
      [P in keyof T & keyof AggregateVideoProgress]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateVideoProgress[P]>
    : Prisma.GetScalarType<T[P], AggregateVideoProgress[P]>
}




export type VideoProgressGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.VideoProgressWhereInput
  orderBy?: Prisma.VideoProgressOrderByWithAggregationInput | Prisma.VideoProgressOrderByWithAggregationInput[]
  by: Prisma.VideoProgressScalarFieldEnum[] | Prisma.VideoProgressScalarFieldEnum
  having?: Prisma.VideoProgressScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: VideoProgressCountAggregateInputType | true
  _avg?: VideoProgressAvgAggregateInputType
  _sum?: VideoProgressSumAggregateInputType
  _min?: VideoProgressMinAggregateInputType
  _max?: VideoProgressMaxAggregateInputType
}

export type VideoProgressGroupByOutputType = {
  id: number
  userId: string
  contentId: number
  currentTimestamp: number
  markAsCompleted: boolean
  updatedAt: Date
  _count: VideoProgressCountAggregateOutputType | null
  _avg: VideoProgressAvgAggregateOutputType | null
  _sum: VideoProgressSumAggregateOutputType | null
  _min: VideoProgressMinAggregateOutputType | null
  _max: VideoProgressMaxAggregateOutputType | null
}

type GetVideoProgressGroupByPayload<T extends VideoProgressGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<VideoProgressGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof VideoProgressGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], VideoProgressGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], VideoProgressGroupByOutputType[P]>
      }
    >
  >



export type VideoProgressWhereInput = {
  AND?: Prisma.VideoProgressWhereInput | Prisma.VideoProgressWhereInput[]
  OR?: Prisma.VideoProgressWhereInput[]
  NOT?: Prisma.VideoProgressWhereInput | Prisma.VideoProgressWhereInput[]
  id?: Prisma.IntFilter<"VideoProgress"> | number
  userId?: Prisma.StringFilter<"VideoProgress"> | string
  contentId?: Prisma.IntFilter<"VideoProgress"> | number
  currentTimestamp?: Prisma.IntFilter<"VideoProgress"> | number
  markAsCompleted?: Prisma.BoolFilter<"VideoProgress"> | boolean
  updatedAt?: Prisma.DateTimeFilter<"VideoProgress"> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  content?: Prisma.XOR<Prisma.ContentScalarRelationFilter, Prisma.ContentWhereInput>
}

export type VideoProgressOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  contentId?: Prisma.SortOrder
  currentTimestamp?: Prisma.SortOrder
  markAsCompleted?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  user?: Prisma.UserOrderByWithRelationInput
  content?: Prisma.ContentOrderByWithRelationInput
}

export type VideoProgressWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  contentId_userId?: Prisma.VideoProgressContentIdUserIdCompoundUniqueInput
  AND?: Prisma.VideoProgressWhereInput | Prisma.VideoProgressWhereInput[]
  OR?: Prisma.VideoProgressWhereInput[]
  NOT?: Prisma.VideoProgressWhereInput | Prisma.VideoProgressWhereInput[]
  userId?: Prisma.StringFilter<"VideoProgress"> | string
  contentId?: Prisma.IntFilter<"VideoProgress"> | number
  currentTimestamp?: Prisma.IntFilter<"VideoProgress"> | number
  markAsCompleted?: Prisma.BoolFilter<"VideoProgress"> | boolean
  updatedAt?: Prisma.DateTimeFilter<"VideoProgress"> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  content?: Prisma.XOR<Prisma.ContentScalarRelationFilter, Prisma.ContentWhereInput>
}, "id" | "contentId_userId">

export type VideoProgressOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  contentId?: Prisma.SortOrder
  currentTimestamp?: Prisma.SortOrder
  markAsCompleted?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.VideoProgressCountOrderByAggregateInput
  _avg?: Prisma.VideoProgressAvgOrderByAggregateInput
  _max?: Prisma.VideoProgressMaxOrderByAggregateInput
  _min?: Prisma.VideoProgressMinOrderByAggregateInput
  _sum?: Prisma.VideoProgressSumOrderByAggregateInput
}

export type VideoProgressScalarWhereWithAggregatesInput = {
  AND?: Prisma.VideoProgressScalarWhereWithAggregatesInput | Prisma.VideoProgressScalarWhereWithAggregatesInput[]
  OR?: Prisma.VideoProgressScalarWhereWithAggregatesInput[]
  NOT?: Prisma.VideoProgressScalarWhereWithAggregatesInput | Prisma.VideoProgressScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"VideoProgress"> | number
  userId?: Prisma.StringWithAggregatesFilter<"VideoProgress"> | string
  contentId?: Prisma.IntWithAggregatesFilter<"VideoProgress"> | number
  currentTimestamp?: Prisma.IntWithAggregatesFilter<"VideoProgress"> | number
  markAsCompleted?: Prisma.BoolWithAggregatesFilter<"VideoProgress"> | boolean
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"VideoProgress"> | Date | string
}

export type VideoProgressCreateInput = {
  currentTimestamp: number
  markAsCompleted?: boolean
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutVideoProgressInput
  content: Prisma.ContentCreateNestedOneWithoutVideoProgressInput
}

export type VideoProgressUncheckedCreateInput = {
  id?: number
  userId: string
  contentId: number
  currentTimestamp: number
  markAsCompleted?: boolean
  updatedAt?: Date | string
}

export type VideoProgressUpdateInput = {
  currentTimestamp?: Prisma.IntFieldUpdateOperationsInput | number
  markAsCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutVideoProgressNestedInput
  content?: Prisma.ContentUpdateOneRequiredWithoutVideoProgressNestedInput
}

export type VideoProgressUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  contentId?: Prisma.IntFieldUpdateOperationsInput | number
  currentTimestamp?: Prisma.IntFieldUpdateOperationsInput | number
  markAsCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type VideoProgressCreateManyInput = {
  id?: number
  userId: string
  contentId: number
  currentTimestamp: number
  markAsCompleted?: boolean
  updatedAt?: Date | string
}

export type VideoProgressUpdateManyMutationInput = {
  currentTimestamp?: Prisma.IntFieldUpdateOperationsInput | number
  markAsCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type VideoProgressUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  contentId?: Prisma.IntFieldUpdateOperationsInput | number
  currentTimestamp?: Prisma.IntFieldUpdateOperationsInput | number
  markAsCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type VideoProgressListRelationFilter = {
  every?: Prisma.VideoProgressWhereInput
  some?: Prisma.VideoProgressWhereInput
  none?: Prisma.VideoProgressWhereInput
}

export type VideoProgressOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type VideoProgressContentIdUserIdCompoundUniqueInput = {
  contentId: number
  userId: string
}

export type VideoProgressCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  contentId?: Prisma.SortOrder
  currentTimestamp?: Prisma.SortOrder
  markAsCompleted?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type VideoProgressAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  contentId?: Prisma.SortOrder
  currentTimestamp?: Prisma.SortOrder
}

export type VideoProgressMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  contentId?: Prisma.SortOrder
  currentTimestamp?: Prisma.SortOrder
  markAsCompleted?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type VideoProgressMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  contentId?: Prisma.SortOrder
  currentTimestamp?: Prisma.SortOrder
  markAsCompleted?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type VideoProgressSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  contentId?: Prisma.SortOrder
  currentTimestamp?: Prisma.SortOrder
}

export type VideoProgressCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.VideoProgressCreateWithoutUserInput, Prisma.VideoProgressUncheckedCreateWithoutUserInput> | Prisma.VideoProgressCreateWithoutUserInput[] | Prisma.VideoProgressUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.VideoProgressCreateOrConnectWithoutUserInput | Prisma.VideoProgressCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.VideoProgressCreateManyUserInputEnvelope
  connect?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
}

export type VideoProgressUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.VideoProgressCreateWithoutUserInput, Prisma.VideoProgressUncheckedCreateWithoutUserInput> | Prisma.VideoProgressCreateWithoutUserInput[] | Prisma.VideoProgressUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.VideoProgressCreateOrConnectWithoutUserInput | Prisma.VideoProgressCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.VideoProgressCreateManyUserInputEnvelope
  connect?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
}

export type VideoProgressUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.VideoProgressCreateWithoutUserInput, Prisma.VideoProgressUncheckedCreateWithoutUserInput> | Prisma.VideoProgressCreateWithoutUserInput[] | Prisma.VideoProgressUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.VideoProgressCreateOrConnectWithoutUserInput | Prisma.VideoProgressCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.VideoProgressUpsertWithWhereUniqueWithoutUserInput | Prisma.VideoProgressUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.VideoProgressCreateManyUserInputEnvelope
  set?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  disconnect?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  delete?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  connect?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  update?: Prisma.VideoProgressUpdateWithWhereUniqueWithoutUserInput | Prisma.VideoProgressUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.VideoProgressUpdateManyWithWhereWithoutUserInput | Prisma.VideoProgressUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.VideoProgressScalarWhereInput | Prisma.VideoProgressScalarWhereInput[]
}

export type VideoProgressUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.VideoProgressCreateWithoutUserInput, Prisma.VideoProgressUncheckedCreateWithoutUserInput> | Prisma.VideoProgressCreateWithoutUserInput[] | Prisma.VideoProgressUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.VideoProgressCreateOrConnectWithoutUserInput | Prisma.VideoProgressCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.VideoProgressUpsertWithWhereUniqueWithoutUserInput | Prisma.VideoProgressUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.VideoProgressCreateManyUserInputEnvelope
  set?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  disconnect?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  delete?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  connect?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  update?: Prisma.VideoProgressUpdateWithWhereUniqueWithoutUserInput | Prisma.VideoProgressUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.VideoProgressUpdateManyWithWhereWithoutUserInput | Prisma.VideoProgressUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.VideoProgressScalarWhereInput | Prisma.VideoProgressScalarWhereInput[]
}

export type VideoProgressCreateNestedManyWithoutContentInput = {
  create?: Prisma.XOR<Prisma.VideoProgressCreateWithoutContentInput, Prisma.VideoProgressUncheckedCreateWithoutContentInput> | Prisma.VideoProgressCreateWithoutContentInput[] | Prisma.VideoProgressUncheckedCreateWithoutContentInput[]
  connectOrCreate?: Prisma.VideoProgressCreateOrConnectWithoutContentInput | Prisma.VideoProgressCreateOrConnectWithoutContentInput[]
  createMany?: Prisma.VideoProgressCreateManyContentInputEnvelope
  connect?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
}

export type VideoProgressUncheckedCreateNestedManyWithoutContentInput = {
  create?: Prisma.XOR<Prisma.VideoProgressCreateWithoutContentInput, Prisma.VideoProgressUncheckedCreateWithoutContentInput> | Prisma.VideoProgressCreateWithoutContentInput[] | Prisma.VideoProgressUncheckedCreateWithoutContentInput[]
  connectOrCreate?: Prisma.VideoProgressCreateOrConnectWithoutContentInput | Prisma.VideoProgressCreateOrConnectWithoutContentInput[]
  createMany?: Prisma.VideoProgressCreateManyContentInputEnvelope
  connect?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
}

export type VideoProgressUpdateManyWithoutContentNestedInput = {
  create?: Prisma.XOR<Prisma.VideoProgressCreateWithoutContentInput, Prisma.VideoProgressUncheckedCreateWithoutContentInput> | Prisma.VideoProgressCreateWithoutContentInput[] | Prisma.VideoProgressUncheckedCreateWithoutContentInput[]
  connectOrCreate?: Prisma.VideoProgressCreateOrConnectWithoutContentInput | Prisma.VideoProgressCreateOrConnectWithoutContentInput[]
  upsert?: Prisma.VideoProgressUpsertWithWhereUniqueWithoutContentInput | Prisma.VideoProgressUpsertWithWhereUniqueWithoutContentInput[]
  createMany?: Prisma.VideoProgressCreateManyContentInputEnvelope
  set?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  disconnect?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  delete?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  connect?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  update?: Prisma.VideoProgressUpdateWithWhereUniqueWithoutContentInput | Prisma.VideoProgressUpdateWithWhereUniqueWithoutContentInput[]
  updateMany?: Prisma.VideoProgressUpdateManyWithWhereWithoutContentInput | Prisma.VideoProgressUpdateManyWithWhereWithoutContentInput[]
  deleteMany?: Prisma.VideoProgressScalarWhereInput | Prisma.VideoProgressScalarWhereInput[]
}

export type VideoProgressUncheckedUpdateManyWithoutContentNestedInput = {
  create?: Prisma.XOR<Prisma.VideoProgressCreateWithoutContentInput, Prisma.VideoProgressUncheckedCreateWithoutContentInput> | Prisma.VideoProgressCreateWithoutContentInput[] | Prisma.VideoProgressUncheckedCreateWithoutContentInput[]
  connectOrCreate?: Prisma.VideoProgressCreateOrConnectWithoutContentInput | Prisma.VideoProgressCreateOrConnectWithoutContentInput[]
  upsert?: Prisma.VideoProgressUpsertWithWhereUniqueWithoutContentInput | Prisma.VideoProgressUpsertWithWhereUniqueWithoutContentInput[]
  createMany?: Prisma.VideoProgressCreateManyContentInputEnvelope
  set?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  disconnect?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  delete?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  connect?: Prisma.VideoProgressWhereUniqueInput | Prisma.VideoProgressWhereUniqueInput[]
  update?: Prisma.VideoProgressUpdateWithWhereUniqueWithoutContentInput | Prisma.VideoProgressUpdateWithWhereUniqueWithoutContentInput[]
  updateMany?: Prisma.VideoProgressUpdateManyWithWhereWithoutContentInput | Prisma.VideoProgressUpdateManyWithWhereWithoutContentInput[]
  deleteMany?: Prisma.VideoProgressScalarWhereInput | Prisma.VideoProgressScalarWhereInput[]
}

export type VideoProgressCreateWithoutUserInput = {
  currentTimestamp: number
  markAsCompleted?: boolean
  updatedAt?: Date | string
  content: Prisma.ContentCreateNestedOneWithoutVideoProgressInput
}

export type VideoProgressUncheckedCreateWithoutUserInput = {
  id?: number
  contentId: number
  currentTimestamp: number
  markAsCompleted?: boolean
  updatedAt?: Date | string
}

export type VideoProgressCreateOrConnectWithoutUserInput = {
  where: Prisma.VideoProgressWhereUniqueInput
  create: Prisma.XOR<Prisma.VideoProgressCreateWithoutUserInput, Prisma.VideoProgressUncheckedCreateWithoutUserInput>
}

export type VideoProgressCreateManyUserInputEnvelope = {
  data: Prisma.VideoProgressCreateManyUserInput | Prisma.VideoProgressCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type VideoProgressUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.VideoProgressWhereUniqueInput
  update: Prisma.XOR<Prisma.VideoProgressUpdateWithoutUserInput, Prisma.VideoProgressUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.VideoProgressCreateWithoutUserInput, Prisma.VideoProgressUncheckedCreateWithoutUserInput>
}

export type VideoProgressUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.VideoProgressWhereUniqueInput
  data: Prisma.XOR<Prisma.VideoProgressUpdateWithoutUserInput, Prisma.VideoProgressUncheckedUpdateWithoutUserInput>
}

export type VideoProgressUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.VideoProgressScalarWhereInput
  data: Prisma.XOR<Prisma.VideoProgressUpdateManyMutationInput, Prisma.VideoProgressUncheckedUpdateManyWithoutUserInput>
}

export type VideoProgressScalarWhereInput = {
  AND?: Prisma.VideoProgressScalarWhereInput | Prisma.VideoProgressScalarWhereInput[]
  OR?: Prisma.VideoProgressScalarWhereInput[]
  NOT?: Prisma.VideoProgressScalarWhereInput | Prisma.VideoProgressScalarWhereInput[]
  id?: Prisma.IntFilter<"VideoProgress"> | number
  userId?: Prisma.StringFilter<"VideoProgress"> | string
  contentId?: Prisma.IntFilter<"VideoProgress"> | number
  currentTimestamp?: Prisma.IntFilter<"VideoProgress"> | number
  markAsCompleted?: Prisma.BoolFilter<"VideoProgress"> | boolean
  updatedAt?: Prisma.DateTimeFilter<"VideoProgress"> | Date | string
}

export type VideoProgressCreateWithoutContentInput = {
  currentTimestamp: number
  markAsCompleted?: boolean
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutVideoProgressInput
}

export type VideoProgressUncheckedCreateWithoutContentInput = {
  id?: number
  userId: string
  currentTimestamp: number
  markAsCompleted?: boolean
  updatedAt?: Date | string
}

export type VideoProgressCreateOrConnectWithoutContentInput = {
  where: Prisma.VideoProgressWhereUniqueInput
  create: Prisma.XOR<Prisma.VideoProgressCreateWithoutContentInput, Prisma.VideoProgressUncheckedCreateWithoutContentInput>
}

export type VideoProgressCreateManyContentInputEnvelope = {
  data: Prisma.VideoProgressCreateManyContentInput | Prisma.VideoProgressCreateManyContentInput[]
  skipDuplicates?: boolean
}

export type VideoProgressUpsertWithWhereUniqueWithoutContentInput = {
  where: Prisma.VideoProgressWhereUniqueInput
  update: Prisma.XOR<Prisma.VideoProgressUpdateWithoutContentInput, Prisma.VideoProgressUncheckedUpdateWithoutContentInput>
  create: Prisma.XOR<Prisma.VideoProgressCreateWithoutContentInput, Prisma.VideoProgressUncheckedCreateWithoutContentInput>
}

export type VideoProgressUpdateWithWhereUniqueWithoutContentInput = {
  where: Prisma.VideoProgressWhereUniqueInput
  data: Prisma.XOR<Prisma.VideoProgressUpdateWithoutContentInput, Prisma.VideoProgressUncheckedUpdateWithoutContentInput>
}

export type VideoProgressUpdateManyWithWhereWithoutContentInput = {
  where: Prisma.VideoProgressScalarWhereInput
  data: Prisma.XOR<Prisma.VideoProgressUpdateManyMutationInput, Prisma.VideoProgressUncheckedUpdateManyWithoutContentInput>
}

export type VideoProgressCreateManyUserInput = {
  id?: number
  contentId: number
  currentTimestamp: number
  markAsCompleted?: boolean
  updatedAt?: Date | string
}

export type VideoProgressUpdateWithoutUserInput = {
  currentTimestamp?: Prisma.IntFieldUpdateOperationsInput | number
  markAsCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  content?: Prisma.ContentUpdateOneRequiredWithoutVideoProgressNestedInput
}

export type VideoProgressUncheckedUpdateWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  contentId?: Prisma.IntFieldUpdateOperationsInput | number
  currentTimestamp?: Prisma.IntFieldUpdateOperationsInput | number
  markAsCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type VideoProgressUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  contentId?: Prisma.IntFieldUpdateOperationsInput | number
  currentTimestamp?: Prisma.IntFieldUpdateOperationsInput | number
  markAsCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type VideoProgressCreateManyContentInput = {
  id?: number
  userId: string
  currentTimestamp: number
  markAsCompleted?: boolean
  updatedAt?: Date | string
}

export type VideoProgressUpdateWithoutContentInput = {
  currentTimestamp?: Prisma.IntFieldUpdateOperationsInput | number
  markAsCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutVideoProgressNestedInput
}

export type VideoProgressUncheckedUpdateWithoutContentInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  currentTimestamp?: Prisma.IntFieldUpdateOperationsInput | number
  markAsCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type VideoProgressUncheckedUpdateManyWithoutContentInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  currentTimestamp?: Prisma.IntFieldUpdateOperationsInput | number
  markAsCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type VideoProgressSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  contentId?: boolean
  currentTimestamp?: boolean
  markAsCompleted?: boolean
  updatedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  content?: boolean | Prisma.ContentDefaultArgs<ExtArgs>
}, ExtArgs["result"]["videoProgress"]>

export type VideoProgressSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  contentId?: boolean
  currentTimestamp?: boolean
  markAsCompleted?: boolean
  updatedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  content?: boolean | Prisma.ContentDefaultArgs<ExtArgs>
}, ExtArgs["result"]["videoProgress"]>

export type VideoProgressSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  contentId?: boolean
  currentTimestamp?: boolean
  markAsCompleted?: boolean
  updatedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  content?: boolean | Prisma.ContentDefaultArgs<ExtArgs>
}, ExtArgs["result"]["videoProgress"]>

export type VideoProgressSelectScalar = {
  id?: boolean
  userId?: boolean
  contentId?: boolean
  currentTimestamp?: boolean
  markAsCompleted?: boolean
  updatedAt?: boolean
}

export type VideoProgressOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "contentId" | "currentTimestamp" | "markAsCompleted" | "updatedAt", ExtArgs["result"]["videoProgress"]>
export type VideoProgressInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  content?: boolean | Prisma.ContentDefaultArgs<ExtArgs>
}
export type VideoProgressIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  content?: boolean | Prisma.ContentDefaultArgs<ExtArgs>
}
export type VideoProgressIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  content?: boolean | Prisma.ContentDefaultArgs<ExtArgs>
}

export type $VideoProgressPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "VideoProgress"
  objects: {
    user: Prisma.$UserPayload<ExtArgs>
    content: Prisma.$ContentPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    userId: string
    contentId: number
    currentTimestamp: number
    markAsCompleted: boolean
    updatedAt: Date
  }, ExtArgs["result"]["videoProgress"]>
  composites: {}
}

export type VideoProgressGetPayload<S extends boolean | null | undefined | VideoProgressDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$VideoProgressPayload, S>

export type VideoProgressCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<VideoProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: VideoProgressCountAggregateInputType | true
  }

export interface VideoProgressDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoProgress'], meta: { name: 'VideoProgress' } }
  /**
   * Find zero or one VideoProgress that matches the filter.
   * @param {VideoProgressFindUniqueArgs} args - Arguments to find a VideoProgress
   * @example
   * // Get one VideoProgress
   * const videoProgress = await prisma.videoProgress.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends VideoProgressFindUniqueArgs>(args: Prisma.SelectSubset<T, VideoProgressFindUniqueArgs<ExtArgs>>): Prisma.Prisma__VideoProgressClient<runtime.Types.Result.GetResult<Prisma.$VideoProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one VideoProgress that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {VideoProgressFindUniqueOrThrowArgs} args - Arguments to find a VideoProgress
   * @example
   * // Get one VideoProgress
   * const videoProgress = await prisma.videoProgress.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends VideoProgressFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, VideoProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__VideoProgressClient<runtime.Types.Result.GetResult<Prisma.$VideoProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first VideoProgress that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {VideoProgressFindFirstArgs} args - Arguments to find a VideoProgress
   * @example
   * // Get one VideoProgress
   * const videoProgress = await prisma.videoProgress.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends VideoProgressFindFirstArgs>(args?: Prisma.SelectSubset<T, VideoProgressFindFirstArgs<ExtArgs>>): Prisma.Prisma__VideoProgressClient<runtime.Types.Result.GetResult<Prisma.$VideoProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first VideoProgress that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {VideoProgressFindFirstOrThrowArgs} args - Arguments to find a VideoProgress
   * @example
   * // Get one VideoProgress
   * const videoProgress = await prisma.videoProgress.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends VideoProgressFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, VideoProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__VideoProgressClient<runtime.Types.Result.GetResult<Prisma.$VideoProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more VideoProgresses that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {VideoProgressFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all VideoProgresses
   * const videoProgresses = await prisma.videoProgress.findMany()
   * 
   * // Get first 10 VideoProgresses
   * const videoProgresses = await prisma.videoProgress.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const videoProgressWithIdOnly = await prisma.videoProgress.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends VideoProgressFindManyArgs>(args?: Prisma.SelectSubset<T, VideoProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$VideoProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a VideoProgress.
   * @param {VideoProgressCreateArgs} args - Arguments to create a VideoProgress.
   * @example
   * // Create one VideoProgress
   * const VideoProgress = await prisma.videoProgress.create({
   *   data: {
   *     // ... data to create a VideoProgress
   *   }
   * })
   * 
   */
  create<T extends VideoProgressCreateArgs>(args: Prisma.SelectSubset<T, VideoProgressCreateArgs<ExtArgs>>): Prisma.Prisma__VideoProgressClient<runtime.Types.Result.GetResult<Prisma.$VideoProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many VideoProgresses.
   * @param {VideoProgressCreateManyArgs} args - Arguments to create many VideoProgresses.
   * @example
   * // Create many VideoProgresses
   * const videoProgress = await prisma.videoProgress.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends VideoProgressCreateManyArgs>(args?: Prisma.SelectSubset<T, VideoProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many VideoProgresses and returns the data saved in the database.
   * @param {VideoProgressCreateManyAndReturnArgs} args - Arguments to create many VideoProgresses.
   * @example
   * // Create many VideoProgresses
   * const videoProgress = await prisma.videoProgress.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many VideoProgresses and only return the `id`
   * const videoProgressWithIdOnly = await prisma.videoProgress.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends VideoProgressCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, VideoProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$VideoProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a VideoProgress.
   * @param {VideoProgressDeleteArgs} args - Arguments to delete one VideoProgress.
   * @example
   * // Delete one VideoProgress
   * const VideoProgress = await prisma.videoProgress.delete({
   *   where: {
   *     // ... filter to delete one VideoProgress
   *   }
   * })
   * 
   */
  delete<T extends VideoProgressDeleteArgs>(args: Prisma.SelectSubset<T, VideoProgressDeleteArgs<ExtArgs>>): Prisma.Prisma__VideoProgressClient<runtime.Types.Result.GetResult<Prisma.$VideoProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one VideoProgress.
   * @param {VideoProgressUpdateArgs} args - Arguments to update one VideoProgress.
   * @example
   * // Update one VideoProgress
   * const videoProgress = await prisma.videoProgress.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends VideoProgressUpdateArgs>(args: Prisma.SelectSubset<T, VideoProgressUpdateArgs<ExtArgs>>): Prisma.Prisma__VideoProgressClient<runtime.Types.Result.GetResult<Prisma.$VideoProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more VideoProgresses.
   * @param {VideoProgressDeleteManyArgs} args - Arguments to filter VideoProgresses to delete.
   * @example
   * // Delete a few VideoProgresses
   * const { count } = await prisma.videoProgress.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends VideoProgressDeleteManyArgs>(args?: Prisma.SelectSubset<T, VideoProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more VideoProgresses.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {VideoProgressUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many VideoProgresses
   * const videoProgress = await prisma.videoProgress.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends VideoProgressUpdateManyArgs>(args: Prisma.SelectSubset<T, VideoProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more VideoProgresses and returns the data updated in the database.
   * @param {VideoProgressUpdateManyAndReturnArgs} args - Arguments to update many VideoProgresses.
   * @example
   * // Update many VideoProgresses
   * const videoProgress = await prisma.videoProgress.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more VideoProgresses and only return the `id`
   * const videoProgressWithIdOnly = await prisma.videoProgress.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends VideoProgressUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, VideoProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$VideoProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one VideoProgress.
   * @param {VideoProgressUpsertArgs} args - Arguments to update or create a VideoProgress.
   * @example
   * // Update or create a VideoProgress
   * const videoProgress = await prisma.videoProgress.upsert({
   *   create: {
   *     // ... data to create a VideoProgress
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the VideoProgress we want to update
   *   }
   * })
   */
  upsert<T extends VideoProgressUpsertArgs>(args: Prisma.SelectSubset<T, VideoProgressUpsertArgs<ExtArgs>>): Prisma.Prisma__VideoProgressClient<runtime.Types.Result.GetResult<Prisma.$VideoProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of VideoProgresses.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {VideoProgressCountArgs} args - Arguments to filter VideoProgresses to count.
   * @example
   * // Count the number of VideoProgresses
   * const count = await prisma.videoProgress.count({
   *   where: {
   *     // ... the filter for the VideoProgresses we want to count
   *   }
   * })
  **/
  count<T extends VideoProgressCountArgs>(
    args?: Prisma.Subset<T, VideoProgressCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], VideoProgressCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a VideoProgress.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {VideoProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends VideoProgressAggregateArgs>(args: Prisma.Subset<T, VideoProgressAggregateArgs>): Prisma.PrismaPromise<GetVideoProgressAggregateType<T>>

  /**
   * Group by VideoProgress.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {VideoProgressGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends VideoProgressGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: VideoProgressGroupByArgs['orderBy'] }
      : { orderBy?: VideoProgressGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, VideoProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the VideoProgress model
 */
readonly fields: VideoProgressFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for VideoProgress.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__VideoProgressClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  content<T extends Prisma.ContentDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ContentDefaultArgs<ExtArgs>>): Prisma.Prisma__ContentClient<runtime.Types.Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the VideoProgress model
 */
export interface VideoProgressFieldRefs {
  readonly id: Prisma.FieldRef<"VideoProgress", 'Int'>
  readonly userId: Prisma.FieldRef<"VideoProgress", 'String'>
  readonly contentId: Prisma.FieldRef<"VideoProgress", 'Int'>
  readonly currentTimestamp: Prisma.FieldRef<"VideoProgress", 'Int'>
  readonly markAsCompleted: Prisma.FieldRef<"VideoProgress", 'Boolean'>
  readonly updatedAt: Prisma.FieldRef<"VideoProgress", 'DateTime'>
}
    

// Custom InputTypes
/**
 * VideoProgress findUnique
 */
export type VideoProgressFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the VideoProgress
   */
  select?: Prisma.VideoProgressSelect<ExtArgs> | null
  /**
   * Omit specific fields from the VideoProgress
   */
  omit?: Prisma.VideoProgressOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.VideoProgressInclude<ExtArgs> | null
  /**
   * Filter, which VideoProgress to fetch.
   */
  where: Prisma.VideoProgressWhereUniqueInput
}

/**
 * VideoProgress findUniqueOrThrow
 */
export type VideoProgressFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the VideoProgress
   */
  select?: Prisma.VideoProgressSelect<ExtArgs> | null
  /**
   * Omit specific fields from the VideoProgress
   */
  omit?: Prisma.VideoProgressOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.VideoProgressInclude<ExtArgs> | null
  /**
   * Filter, which VideoProgress to fetch.
   */
  where: Prisma.VideoProgressWhereUniqueInput
}

/**
 * VideoProgress findFirst
 */
export type VideoProgressFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the VideoProgress
   */
  select?: Prisma.VideoProgressSelect<ExtArgs> | null
  /**
   * Omit specific fields from the VideoProgress
   */
  omit?: Prisma.VideoProgressOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.VideoProgressInclude<ExtArgs> | null
  /**
   * Filter, which VideoProgress to fetch.
   */
  where?: Prisma.VideoProgressWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of VideoProgresses to fetch.
   */
  orderBy?: Prisma.VideoProgressOrderByWithRelationInput | Prisma.VideoProgressOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for VideoProgresses.
   */
  cursor?: Prisma.VideoProgressWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` VideoProgresses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` VideoProgresses.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of VideoProgresses.
   */
  distinct?: Prisma.VideoProgressScalarFieldEnum | Prisma.VideoProgressScalarFieldEnum[]
}

/**
 * VideoProgress findFirstOrThrow
 */
export type VideoProgressFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the VideoProgress
   */
  select?: Prisma.VideoProgressSelect<ExtArgs> | null
  /**
   * Omit specific fields from the VideoProgress
   */
  omit?: Prisma.VideoProgressOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.VideoProgressInclude<ExtArgs> | null
  /**
   * Filter, which VideoProgress to fetch.
   */
  where?: Prisma.VideoProgressWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of VideoProgresses to fetch.
   */
  orderBy?: Prisma.VideoProgressOrderByWithRelationInput | Prisma.VideoProgressOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for VideoProgresses.
   */
  cursor?: Prisma.VideoProgressWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` VideoProgresses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` VideoProgresses.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of VideoProgresses.
   */
  distinct?: Prisma.VideoProgressScalarFieldEnum | Prisma.VideoProgressScalarFieldEnum[]
}

/**
 * VideoProgress findMany
 */
export type VideoProgressFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the VideoProgress
   */
  select?: Prisma.VideoProgressSelect<ExtArgs> | null
  /**
   * Omit specific fields from the VideoProgress
   */
  omit?: Prisma.VideoProgressOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.VideoProgressInclude<ExtArgs> | null
  /**
   * Filter, which VideoProgresses to fetch.
   */
  where?: Prisma.VideoProgressWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of VideoProgresses to fetch.
   */
  orderBy?: Prisma.VideoProgressOrderByWithRelationInput | Prisma.VideoProgressOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing VideoProgresses.
   */
  cursor?: Prisma.VideoProgressWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` VideoProgresses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` VideoProgresses.
   */
  skip?: number
  distinct?: Prisma.VideoProgressScalarFieldEnum | Prisma.VideoProgressScalarFieldEnum[]
}

/**
 * VideoProgress create
 */
export type VideoProgressCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the VideoProgress
   */
  select?: Prisma.VideoProgressSelect<ExtArgs> | null
  /**
   * Omit specific fields from the VideoProgress
   */
  omit?: Prisma.VideoProgressOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.VideoProgressInclude<ExtArgs> | null
  /**
   * The data needed to create a VideoProgress.
   */
  data: Prisma.XOR<Prisma.VideoProgressCreateInput, Prisma.VideoProgressUncheckedCreateInput>
}

/**
 * VideoProgress createMany
 */
export type VideoProgressCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many VideoProgresses.
   */
  data: Prisma.VideoProgressCreateManyInput | Prisma.VideoProgressCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * VideoProgress createManyAndReturn
 */
export type VideoProgressCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the VideoProgress
   */
  select?: Prisma.VideoProgressSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the VideoProgress
   */
  omit?: Prisma.VideoProgressOmit<ExtArgs> | null
  /**
   * The data used to create many VideoProgresses.
   */
  data: Prisma.VideoProgressCreateManyInput | Prisma.VideoProgressCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.VideoProgressIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * VideoProgress update
 */
export type VideoProgressUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the VideoProgress
   */
  select?: Prisma.VideoProgressSelect<ExtArgs> | null
  /**
   * Omit specific fields from the VideoProgress
   */
  omit?: Prisma.VideoProgressOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.VideoProgressInclude<ExtArgs> | null
  /**
   * The data needed to update a VideoProgress.
   */
  data: Prisma.XOR<Prisma.VideoProgressUpdateInput, Prisma.VideoProgressUncheckedUpdateInput>
  /**
   * Choose, which VideoProgress to update.
   */
  where: Prisma.VideoProgressWhereUniqueInput
}

/**
 * VideoProgress updateMany
 */
export type VideoProgressUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update VideoProgresses.
   */
  data: Prisma.XOR<Prisma.VideoProgressUpdateManyMutationInput, Prisma.VideoProgressUncheckedUpdateManyInput>
  /**
   * Filter which VideoProgresses to update
   */
  where?: Prisma.VideoProgressWhereInput
  /**
   * Limit how many VideoProgresses to update.
   */
  limit?: number
}

/**
 * VideoProgress updateManyAndReturn
 */
export type VideoProgressUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the VideoProgress
   */
  select?: Prisma.VideoProgressSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the VideoProgress
   */
  omit?: Prisma.VideoProgressOmit<ExtArgs> | null
  /**
   * The data used to update VideoProgresses.
   */
  data: Prisma.XOR<Prisma.VideoProgressUpdateManyMutationInput, Prisma.VideoProgressUncheckedUpdateManyInput>
  /**
   * Filter which VideoProgresses to update
   */
  where?: Prisma.VideoProgressWhereInput
  /**
   * Limit how many VideoProgresses to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.VideoProgressIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * VideoProgress upsert
 */
export type VideoProgressUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the VideoProgress
   */
  select?: Prisma.VideoProgressSelect<ExtArgs> | null
  /**
   * Omit specific fields from the VideoProgress
   */
  omit?: Prisma.VideoProgressOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.VideoProgressInclude<ExtArgs> | null
  /**
   * The filter to search for the VideoProgress to update in case it exists.
   */
  where: Prisma.VideoProgressWhereUniqueInput
  /**
   * In case the VideoProgress found by the `where` argument doesn't exist, create a new VideoProgress with this data.
   */
  create: Prisma.XOR<Prisma.VideoProgressCreateInput, Prisma.VideoProgressUncheckedCreateInput>
  /**
   * In case the VideoProgress was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.VideoProgressUpdateInput, Prisma.VideoProgressUncheckedUpdateInput>
}

/**
 * VideoProgress delete
 */
export type VideoProgressDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the VideoProgress
   */
  select?: Prisma.VideoProgressSelect<ExtArgs> | null
  /**
   * Omit specific fields from the VideoProgress
   */
  omit?: Prisma.VideoProgressOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.VideoProgressInclude<ExtArgs> | null
  /**
   * Filter which VideoProgress to delete.
   */
  where: Prisma.VideoProgressWhereUniqueInput
}

/**
 * VideoProgress deleteMany
 */
export type VideoProgressDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which VideoProgresses to delete
   */
  where?: Prisma.VideoProgressWhereInput
  /**
   * Limit how many VideoProgresses to delete.
   */
  limit?: number
}

/**
 * VideoProgress without action
 */
export type VideoProgressDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the VideoProgress
   */
  select?: Prisma.VideoProgressSelect<ExtArgs> | null
  /**
   * Omit specific fields from the VideoProgress
   */
  omit?: Prisma.VideoProgressOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.VideoProgressInclude<ExtArgs> | null
}
